# -*- coding: utf-8 -*-
"""Supplybot_IK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JzBu0STRyRwz2hbK2BmxMqE7KzkHcwdq

Inverse Kinematics validation:
(Try to run this code in VScode or pycharm to get a joint angles and circle at every instant)
"""

#INVERSE KINEMATICS
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
from sympy import symbols,sin,cos,Matrix,pprint

a, d, alpha, theta, theta1, theta2, theta3, theta4, theta5, theta6,t = 
sp.symbols('a d alpha theta theta1 theta2 theta3 theta4 theta5 theta6 t')    

# Transformation matrix 
T = sp.Matrix([[sp.cos(theta), -sp.sin(theta)*sp.cos(alpha), sp.sin(theta)*sp.sin(alpha), a*sp.cos(theta)],
              [sp.sin(theta), sp.cos(theta)*sp.cos(alpha), -sp.cos(theta)*sp.sin(alpha), a*sp.sin(theta)],
              [0, sp.sin(alpha), sp.cos(alpha), d],
              [0, 0, 0, 1]])
print("The Transformation Matrix:")
pprint(T)
A1 = T.subs([(d, 0.089159), (a, 0), (alpha, sp.pi/2), (theta, theta1)])
print("\n")
pprint(A1)
T2 = T.subs([(d, 0), (a, -0.425), (alpha, 0), (theta, theta2)])
A2 = A1*T2
print("\n")
pprint(A2)
T3 = T.subs([(d, 0), (a, -0.39225), (alpha, 0), (theta, theta3)]) 
A3 = A1*T2*T3
print("\n")
pprint(A3)
T4 = T.subs([(d, 0.10915), (a, 0), (alpha, sp.pi/2), (theta, theta4)])
A4 = A1*T2*T3*T4
print("\n")
pprint(41)
T5 = T.subs([(d, 0.09465), (a, 0), (alpha, -sp.pi/2), (theta, theta5)])
A5 = A1*T2*T3*T4*T5
print("\n")
pprint(A5)
T6 = T.subs([(d, 0.0823), (a, 0), (alpha, 0), (theta, theta6)])
A6 = A1*T2*T3*T4*T5*T6
print("\n")
pprint(A6)

J = sp.Matrix([[sp.diff(A6[0,3],theta1),sp.diff(A6[0,3],theta2),sp.diff(A6[0,3],theta3),sp.diff(A6[0,3],theta4),sp.diff(A6[0,3],theta5),sp.diff(A6[0,3],theta6)],
               [sp.diff(A6[1,3],theta1),sp.diff(A6[1,3],theta2),sp.diff(A6[1,3],theta3),sp.diff(A6[1,3],theta4),sp.diff(A6[1,3],theta5),sp.diff(A6[1,3],theta6)],
               [sp.diff(A6[2,3],theta1),sp.diff(A6[2,3],theta2),sp.diff(A6[2,3],theta3),sp.diff(A6[2,3],theta4),sp.diff(A6[2,3],theta5),sp.diff(A6[2,3],theta6)],
               [A1[0,2],A2[0,2],A4[0,2],A5[0,2],A6[0,2],A6[0,2]],
               [A1[1,2],A2[1,2],A4[1,2],A5[1,2],A6[1,2],A6[1,2]],
               [A1[2,2],A2[2,2],A4[2,2],A5[2,2],A6[2,2],A6[2,2]]])
print("The Jacobian Matrix ")
pprint(J)

omega=(2*3.14)/5
dt=0.125
time = np.arange(0, 5, dt)

x_dot=sp.Matrix([[0],[omega*0.1*sp.cos(omega*t)],[-omega*0.1*sp.sin(omega*t)],[0],[0],[0]])

q=sp.Matrix([[sp.pi/2],[-sp.pi/2],[sp.pi/2],[-sp.pi],[-sp.pi/2],[0]])  

fig = plt.figure(figsize = (10, 10))         
ax = plt.axes(projection ="3d")
plt.title("End effector trajectory to draw the circle")
ax = fig.add_subplot(111, projection='3d')
ax.set_xlim(1,0)
ax.set_ylim(-0.5,0.5)
ax.set_zlim(0.4,1)
ax.set_xlabel('X -AXIS')
ax.set_ylabel('Y -AXIS')
ax.set_zlabel('Z -AXIS')

for i in range(0,40):
 #substituting the joint angles in final transformation matrix
    A6_x_y_z=A6.subs([(theta1, q[0]), (theta2, q[1]), (theta3, q[2]), (theta4, q[3]), (theta5, q[4]), (theta6, q[5])])       
    ax.scatter3D(A6_x_y_z[0,-1], A6_x_y_z[1,-1], A6_x_y_z[2,-1], color = "red")
    J_inv=J.subs([(theta1, q[0]), (theta2, q[1]), (theta3, q[2]), (theta4, q[3]), (theta5, q[4]), (theta6, q[5])])
    
    #taking jacobian inverse with current joint angles
    J_inv=(J_inv.evalf()).inv()                                                                
    
    X_ = x_dot.subs([(t,time[i])]).evalf()
    q_dot=(J_inv * X_).evalf()  
    q = q + q_dot *dt
    plt.pause(0.1)

plt.show()